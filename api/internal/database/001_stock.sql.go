// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 001_stock.sql

package database

import (
	"context"
	"database/sql"
)

const bestDividendStocksByIndustry = `-- name: BestDividendStocksByIndustry :many
SELECT 
    s1.symbol, 
    s1.displayName, 
    s1.industry, 
    s1.dividendYield AS max_div
FROM 
    Stock s1
JOIN 
    Industry i ON LOWER(s1.industry) = LOWER(i.industry)
WHERE 
    i.id = ?
    AND s1.industry IS NOT NULL
    AND TRIM(s1.industry) != ''
    AND (
        SELECT COUNT(*) 
        FROM Stock s2 
        WHERE LOWER(s2.industry) = LOWER(s1.industry)
          AND s2.dividendYield > s1.dividendYield
    ) < 5
ORDER BY 
    s1.dividendYield DESC 
LIMIT 5
`

type BestDividendStocksByIndustryRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	Industry    sql.NullString
	MaxDiv      sql.NullFloat64
}

func (q *Queries) BestDividendStocksByIndustry(ctx context.Context, id int64) ([]BestDividendStocksByIndustryRow, error) {
	rows, err := q.db.QueryContext(ctx, bestDividendStocksByIndustry, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BestDividendStocksByIndustryRow
	for rows.Next() {
		var i BestDividendStocksByIndustryRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.Industry,
			&i.MaxDiv,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const distinctIndustries = `-- name: DistinctIndustries :many
SELECT id, industry FROM Industry
`

func (q *Queries) DistinctIndustries(ctx context.Context) ([]Industry, error) {
	rows, err := q.db.QueryContext(ctx, distinctIndustries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Industry
	for rows.Next() {
		var i Industry
		if err := rows.Scan(&i.ID, &i.Industry); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const distinctSectors = `-- name: DistinctSectors :many
SELECT id, sector_name FROM Sector
`

func (q *Queries) DistinctSectors(ctx context.Context) ([]Sector, error) {
	rows, err := q.db.QueryContext(ctx, distinctSectors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sector
	for rows.Next() {
		var i Sector
		if err := rows.Scan(&i.ID, &i.SectorName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const earningsQuartGrowthBySector = `-- name: EarningsQuartGrowthBySector :many
SELECT 
    s1.symbol, 
    s1.displayName, 
    sec.sector_name, 
    s1.earningsQuarterlyGrowth AS maxFCF
FROM 
    Stock s1
JOIN 
    Sector sec ON LOWER(s1.sector) = LOWER(sec.sector_name)
WHERE 
    sec.id = ?
    AND (
        SELECT COUNT(*) 
        FROM Stock s2 
        WHERE LOWER(s2.sector) = LOWER(s1.sector)
          AND s2.earningsQuarterlyGrowth > s1.earningsQuarterlyGrowth
    ) < 5
ORDER BY 
    s1.earningsQuarterlyGrowth DESC 
LIMIT 5
`

type EarningsQuartGrowthBySectorRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	SectorName  sql.NullString
	Maxfcf      sql.NullFloat64
}

func (q *Queries) EarningsQuartGrowthBySector(ctx context.Context, id int64) ([]EarningsQuartGrowthBySectorRow, error) {
	rows, err := q.db.QueryContext(ctx, earningsQuartGrowthBySector, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EarningsQuartGrowthBySectorRow
	for rows.Next() {
		var i EarningsQuartGrowthBySectorRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.SectorName,
			&i.Maxfcf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockDataBySymbol = `-- name: GetStockDataBySymbol :one
SELECT id, address1, city, state, zip, country, phone, fax, website, industry, industrykey, industrydisp, sector, sectorkey, sectordisp, longbusinesssummary, fulltimeemployees, auditrisk, boardrisk, compensationrisk, shareholderrightsrisk, overallrisk, governanceepochdate, compensationasofepochdate, irwebsite, maxage, pricehint, previousclose, open, daylow, dayhigh, regularmarketpreviousclose, regularmarketopen, regularmarketdaylow, regularmarketdayhigh, dividendrate, dividendyield, exdividenddate, payoutratio, fiveyearavgdividendyield, beta, trailingpe, forwardpe, volume, regularmarketvolume, averagevolume, averagevolume10days, averagedailyvolume10day, bid, ask, bidsize, asksize, marketcap, fiftytwoweeklow, fiftytwoweekhigh, pricetosalestrailing12months, fiftydayaverage, twohundreddayaverage, trailingannualdividendrate, trailingannualdividendyield, currency, tradeable, enterprisevalue, profitmargins, floatshares, sharesoutstanding, sharesshort, sharesshortpriormonth, sharesshortpreviousmonthdate, dateshortinterest, sharespercentsharesout, heldpercentinsiders, heldpercentinstitutions, shortratio, shortpercentoffloat, impliedsharesoutstanding, bookvalue, pricetobook, lastfiscalyearend, nextfiscalyearend, mostrecentquarter, earningsquarterlygrowth, netincometocommon, trailingeps, forwardeps, lastsplitfactor, lastsplitdate, enterprisetorevenue, enterprisetoebitda, fiftytwoweekchange, sandp52weekchange, lastdividendvalue, lastdividenddate, quotetype, currentprice, targethighprice, targetlowprice, targetmeanprice, targetmedianprice, recommendationmean, recommendationkey, numberofanalystopinions, totalcash, totalcashpershare, ebitda, totaldebt, quickratio, currentratio, totalrevenue, debttoequity, revenuepershare, returnonassets, returnonequity, grossprofits, freecashflow, operatingcashflow, earningsgrowth, revenuegrowth, grossmargins, ebitdamargins, operatingmargins, financialcurrency, symbol, language, region, typedisp, quotesourcename, triggerable, custompricealertconfidence, postmarkettime, regularmarkettime, exchange, messageboardid, exchangetimezonename, shortname, longname, postmarketchangepercent, postmarketprice, postmarketchange, regularmarketchange, regularmarketdayrange, fullexchangename, averagedailyvolume3month, fiftytwoweeklowchange, fiftytwoweeklowchangepercent, fiftytwoweekrange, fiftytwoweekhighchange, fiftytwoweekhighchangepercent, fiftytwoweekchangepercent, dividenddate, earningstimestamp, earningstimestampstart, earningstimestampend, earningscalltimestampstart, earningscalltimestampend, isearningsdateestimate, epstrailingtwelvemonths, epsforward, epscurrentyear, priceepscurrentyear, fiftydayaveragechange, fiftydayaveragechangepercent, twohundreddayaveragechange, twohundreddayaveragechangepercent, sourceinterval, exchangedatadelayedby, hasprepostmarketdata, firsttradedatemilliseconds, exchangetimezoneshortname, gmtoffsetmilliseconds, market, esgpopulated, regularmarketchangepercent, regularmarketprice, marketstate, averageanalystrating, cryptotradeable, displayname, trailingpegratio, address2, prevname, namechangedate, ipoexpecteddate, prevticker, tickerchangedate, prevexchange, exchangetransferdate, newlistingdate, industrysymbol FROM Stock WHERE symbol = ?
`

func (q *Queries) GetStockDataBySymbol(ctx context.Context, symbol sql.NullString) (Stock, error) {
	row := q.db.QueryRowContext(ctx, getStockDataBySymbol, symbol)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Address1,
		&i.City,
		&i.State,
		&i.Zip,
		&i.Country,
		&i.Phone,
		&i.Fax,
		&i.Website,
		&i.Industry,
		&i.Industrykey,
		&i.Industrydisp,
		&i.Sector,
		&i.Sectorkey,
		&i.Sectordisp,
		&i.Longbusinesssummary,
		&i.Fulltimeemployees,
		&i.Auditrisk,
		&i.Boardrisk,
		&i.Compensationrisk,
		&i.Shareholderrightsrisk,
		&i.Overallrisk,
		&i.Governanceepochdate,
		&i.Compensationasofepochdate,
		&i.Irwebsite,
		&i.Maxage,
		&i.Pricehint,
		&i.Previousclose,
		&i.Open,
		&i.Daylow,
		&i.Dayhigh,
		&i.Regularmarketpreviousclose,
		&i.Regularmarketopen,
		&i.Regularmarketdaylow,
		&i.Regularmarketdayhigh,
		&i.Dividendrate,
		&i.Dividendyield,
		&i.Exdividenddate,
		&i.Payoutratio,
		&i.Fiveyearavgdividendyield,
		&i.Beta,
		&i.Trailingpe,
		&i.Forwardpe,
		&i.Volume,
		&i.Regularmarketvolume,
		&i.Averagevolume,
		&i.Averagevolume10days,
		&i.Averagedailyvolume10day,
		&i.Bid,
		&i.Ask,
		&i.Bidsize,
		&i.Asksize,
		&i.Marketcap,
		&i.Fiftytwoweeklow,
		&i.Fiftytwoweekhigh,
		&i.Pricetosalestrailing12months,
		&i.Fiftydayaverage,
		&i.Twohundreddayaverage,
		&i.Trailingannualdividendrate,
		&i.Trailingannualdividendyield,
		&i.Currency,
		&i.Tradeable,
		&i.Enterprisevalue,
		&i.Profitmargins,
		&i.Floatshares,
		&i.Sharesoutstanding,
		&i.Sharesshort,
		&i.Sharesshortpriormonth,
		&i.Sharesshortpreviousmonthdate,
		&i.Dateshortinterest,
		&i.Sharespercentsharesout,
		&i.Heldpercentinsiders,
		&i.Heldpercentinstitutions,
		&i.Shortratio,
		&i.Shortpercentoffloat,
		&i.Impliedsharesoutstanding,
		&i.Bookvalue,
		&i.Pricetobook,
		&i.Lastfiscalyearend,
		&i.Nextfiscalyearend,
		&i.Mostrecentquarter,
		&i.Earningsquarterlygrowth,
		&i.Netincometocommon,
		&i.Trailingeps,
		&i.Forwardeps,
		&i.Lastsplitfactor,
		&i.Lastsplitdate,
		&i.Enterprisetorevenue,
		&i.Enterprisetoebitda,
		&i.Fiftytwoweekchange,
		&i.Sandp52weekchange,
		&i.Lastdividendvalue,
		&i.Lastdividenddate,
		&i.Quotetype,
		&i.Currentprice,
		&i.Targethighprice,
		&i.Targetlowprice,
		&i.Targetmeanprice,
		&i.Targetmedianprice,
		&i.Recommendationmean,
		&i.Recommendationkey,
		&i.Numberofanalystopinions,
		&i.Totalcash,
		&i.Totalcashpershare,
		&i.Ebitda,
		&i.Totaldebt,
		&i.Quickratio,
		&i.Currentratio,
		&i.Totalrevenue,
		&i.Debttoequity,
		&i.Revenuepershare,
		&i.Returnonassets,
		&i.Returnonequity,
		&i.Grossprofits,
		&i.Freecashflow,
		&i.Operatingcashflow,
		&i.Earningsgrowth,
		&i.Revenuegrowth,
		&i.Grossmargins,
		&i.Ebitdamargins,
		&i.Operatingmargins,
		&i.Financialcurrency,
		&i.Symbol,
		&i.Language,
		&i.Region,
		&i.Typedisp,
		&i.Quotesourcename,
		&i.Triggerable,
		&i.Custompricealertconfidence,
		&i.Postmarkettime,
		&i.Regularmarkettime,
		&i.Exchange,
		&i.Messageboardid,
		&i.Exchangetimezonename,
		&i.Shortname,
		&i.Longname,
		&i.Postmarketchangepercent,
		&i.Postmarketprice,
		&i.Postmarketchange,
		&i.Regularmarketchange,
		&i.Regularmarketdayrange,
		&i.Fullexchangename,
		&i.Averagedailyvolume3month,
		&i.Fiftytwoweeklowchange,
		&i.Fiftytwoweeklowchangepercent,
		&i.Fiftytwoweekrange,
		&i.Fiftytwoweekhighchange,
		&i.Fiftytwoweekhighchangepercent,
		&i.Fiftytwoweekchangepercent,
		&i.Dividenddate,
		&i.Earningstimestamp,
		&i.Earningstimestampstart,
		&i.Earningstimestampend,
		&i.Earningscalltimestampstart,
		&i.Earningscalltimestampend,
		&i.Isearningsdateestimate,
		&i.Epstrailingtwelvemonths,
		&i.Epsforward,
		&i.Epscurrentyear,
		&i.Priceepscurrentyear,
		&i.Fiftydayaveragechange,
		&i.Fiftydayaveragechangepercent,
		&i.Twohundreddayaveragechange,
		&i.Twohundreddayaveragechangepercent,
		&i.Sourceinterval,
		&i.Exchangedatadelayedby,
		&i.Hasprepostmarketdata,
		&i.Firsttradedatemilliseconds,
		&i.Exchangetimezoneshortname,
		&i.Gmtoffsetmilliseconds,
		&i.Market,
		&i.Esgpopulated,
		&i.Regularmarketchangepercent,
		&i.Regularmarketprice,
		&i.Marketstate,
		&i.Averageanalystrating,
		&i.Cryptotradeable,
		&i.Displayname,
		&i.Trailingpegratio,
		&i.Address2,
		&i.Prevname,
		&i.Namechangedate,
		&i.Ipoexpecteddate,
		&i.Prevticker,
		&i.Tickerchangedate,
		&i.Prevexchange,
		&i.Exchangetransferdate,
		&i.Newlistingdate,
		&i.Industrysymbol,
	)
	return i, err
}

const highCashFlowBySector = `-- name: HighCashFlowBySector :many
SELECT 
    s1.symbol, 
    s1.displayName, 
    s1.sector, 
    s1.freeCashflow AS maxFCF
FROM 
    Stock s1
JOIN 
    Sector sec ON LOWER(s1.sector) = LOWER(sec.sector_name)
WHERE 
    sec.id = ?
    AND (
        SELECT COUNT(*) 
        FROM Stock s2 
        WHERE LOWER(s2.sector) = LOWER(s1.sector)
          AND s2.freeCashflow > s1.freeCashflow
    ) < 5
ORDER BY 
    s1.freeCashflow DESC 
LIMIT 5
`

type HighCashFlowBySectorRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	Sector      sql.NullString
	Maxfcf      sql.NullInt64
}

func (q *Queries) HighCashFlowBySector(ctx context.Context, id int64) ([]HighCashFlowBySectorRow, error) {
	rows, err := q.db.QueryContext(ctx, highCashFlowBySector, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HighCashFlowBySectorRow
	for rows.Next() {
		var i HighCashFlowBySectorRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.Sector,
			&i.Maxfcf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const highDividendBySector = `-- name: HighDividendBySector :many
SELECT 
    s1.symbol, 
    s1.displayName, 
    s1.sector, 
    s1.dividendYield AS max_div
FROM 
    Stock s1
JOIN 
    Sector sec ON LOWER(s1.sector) = LOWER(sec.sector_name)
WHERE 
    sec.id = ?
    AND s1.dividendYield IS NOT NULL
    AND (
        SELECT COUNT(*)
        FROM Stock s2
        WHERE LOWER(s2.sector) = LOWER(s1.sector)
          AND s2.dividendYield > s1.dividendYield
    ) < 5
ORDER BY 
    s1.dividendYield DESC
LIMIT 5
`

type HighDividendBySectorRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	Sector      sql.NullString
	MaxDiv      sql.NullFloat64
}

func (q *Queries) HighDividendBySector(ctx context.Context, id int64) ([]HighDividendBySectorRow, error) {
	rows, err := q.db.QueryContext(ctx, highDividendBySector, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HighDividendBySectorRow
	for rows.Next() {
		var i HighDividendBySectorRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.Sector,
			&i.MaxDiv,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
