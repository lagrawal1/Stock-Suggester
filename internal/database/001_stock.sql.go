// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 001_stock.sql

package database

import (
	"context"
	"database/sql"
)

const bestDividendStocksByIndustry = `-- name: BestDividendStocksByIndustry :many
;

SELECT s1.symbol, s1.displayName, s1.industry, s1.dividendYield AS max_div
FROM Stock s1
WHERE s1.industry != 'None' 
  AND s1.industry != '' 
  AND LOWER(s1.industry )= ?
  AND (
      SELECT COUNT(*) 
      FROM Stock s2 
      WHERE s2.industry = s1.industry 
        AND s2.dividendYield > s1.dividendYield
  ) < ?
ORDER BY s1.dividendYield DESC LIMIT 5
`

type BestDividendStocksByIndustryParams struct {
	Industry   sql.NullString
	Industry_2 sql.NullString
}

type BestDividendStocksByIndustryRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	Industry    sql.NullString
	MaxDiv      sql.NullFloat64
}

func (q *Queries) BestDividendStocksByIndustry(ctx context.Context, arg BestDividendStocksByIndustryParams) ([]BestDividendStocksByIndustryRow, error) {
	rows, err := q.db.QueryContext(ctx, bestDividendStocksByIndustry, arg.Industry, arg.Industry_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BestDividendStocksByIndustryRow
	for rows.Next() {
		var i BestDividendStocksByIndustryRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.Industry,
			&i.MaxDiv,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const distinctIndustry = `-- name: DistinctIndustry :many
SELECT DISTINCT industry FROM Stock WHERE industry != 'None' AND industry IS NOT NULL
`

func (q *Queries) DistinctIndustry(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, distinctIndustry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var industry sql.NullString
		if err := rows.Scan(&industry); err != nil {
			return nil, err
		}
		items = append(items, industry)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const distinctSectors = `-- name: DistinctSectors :many
;

SELECT DISTINCT sector FROM Stock WHERE sector != 'None' AND sector IS NOT NULL
`

func (q *Queries) DistinctSectors(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, distinctSectors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var sector sql.NullString
		if err := rows.Scan(&sector); err != nil {
			return nil, err
		}
		items = append(items, sector)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const earningsQuartGrowthBySector = `-- name: EarningsQuartGrowthBySector :many
SELECT s1.symbol, s1.displayName, s1.sector, s1.earningsQuarterlyGrowth AS maxFCF
FROM Stock s1
WHERE s1.sector != 'None' 
  AND s1.sector != '' 
  AND LOWER(s1.sector) = ?
  AND (
      SELECT COUNT(*) 
      FROM Stock s2 
      WHERE LOWER(s2.sector) = LOWER(s1.sector )
        AND s2.earningsQuarterlyGrowth > s1.earningsQuarterlyGrowth
  ) < ?
ORDER BY s1.earningsQuarterlyGrowth DESC LIMIT 5
`

type EarningsQuartGrowthBySectorParams struct {
	Sector   sql.NullString
	Sector_2 sql.NullString
}

type EarningsQuartGrowthBySectorRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	Sector      sql.NullString
	Maxfcf      sql.NullFloat64
}

func (q *Queries) EarningsQuartGrowthBySector(ctx context.Context, arg EarningsQuartGrowthBySectorParams) ([]EarningsQuartGrowthBySectorRow, error) {
	rows, err := q.db.QueryContext(ctx, earningsQuartGrowthBySector, arg.Sector, arg.Sector_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EarningsQuartGrowthBySectorRow
	for rows.Next() {
		var i EarningsQuartGrowthBySectorRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.Sector,
			&i.Maxfcf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockDataBySymbol = `-- name: GetStockDataBySymbol :one
SELECT id, address1, city, state, zip, country, phone, fax, website, industry, industrykey, industrydisp, sector, sectorkey, sectordisp, longbusinesssummary, fulltimeemployees, auditrisk, boardrisk, compensationrisk, shareholderrightsrisk, overallrisk, governanceepochdate, compensationasofepochdate, irwebsite, maxage, pricehint, previousclose, open, daylow, dayhigh, regularmarketpreviousclose, regularmarketopen, regularmarketdaylow, regularmarketdayhigh, dividendrate, dividendyield, exdividenddate, payoutratio, fiveyearavgdividendyield, beta, trailingpe, forwardpe, volume, regularmarketvolume, averagevolume, averagevolume10days, averagedailyvolume10day, bid, ask, bidsize, asksize, marketcap, fiftytwoweeklow, fiftytwoweekhigh, pricetosalestrailing12months, fiftydayaverage, twohundreddayaverage, trailingannualdividendrate, trailingannualdividendyield, currency, tradeable, enterprisevalue, profitmargins, floatshares, sharesoutstanding, sharesshort, sharesshortpriormonth, sharesshortpreviousmonthdate, dateshortinterest, sharespercentsharesout, heldpercentinsiders, heldpercentinstitutions, shortratio, shortpercentoffloat, impliedsharesoutstanding, bookvalue, pricetobook, lastfiscalyearend, nextfiscalyearend, mostrecentquarter, earningsquarterlygrowth, netincometocommon, trailingeps, forwardeps, lastsplitfactor, lastsplitdate, enterprisetorevenue, enterprisetoebitda, fiftytwoweekchange, sandp52weekchange, lastdividendvalue, lastdividenddate, quotetype, currentprice, targethighprice, targetlowprice, targetmeanprice, targetmedianprice, recommendationmean, recommendationkey, numberofanalystopinions, totalcash, totalcashpershare, ebitda, totaldebt, quickratio, currentratio, totalrevenue, debttoequity, revenuepershare, returnonassets, returnonequity, grossprofits, freecashflow, operatingcashflow, earningsgrowth, revenuegrowth, grossmargins, ebitdamargins, operatingmargins, financialcurrency, symbol, language, region, typedisp, quotesourcename, triggerable, custompricealertconfidence, postmarkettime, regularmarkettime, exchange, messageboardid, exchangetimezonename, shortname, longname, postmarketchangepercent, postmarketprice, postmarketchange, regularmarketchange, regularmarketdayrange, fullexchangename, averagedailyvolume3month, fiftytwoweeklowchange, fiftytwoweeklowchangepercent, fiftytwoweekrange, fiftytwoweekhighchange, fiftytwoweekhighchangepercent, fiftytwoweekchangepercent, dividenddate, earningstimestamp, earningstimestampstart, earningstimestampend, earningscalltimestampstart, earningscalltimestampend, isearningsdateestimate, epstrailingtwelvemonths, epsforward, epscurrentyear, priceepscurrentyear, fiftydayaveragechange, fiftydayaveragechangepercent, twohundreddayaveragechange, twohundreddayaveragechangepercent, sourceinterval, exchangedatadelayedby, hasprepostmarketdata, firsttradedatemilliseconds, exchangetimezoneshortname, gmtoffsetmilliseconds, market, esgpopulated, regularmarketchangepercent, regularmarketprice, marketstate, averageanalystrating, cryptotradeable, displayname, trailingpegratio, address2, prevname, namechangedate, ipoexpecteddate, prevticker, tickerchangedate, prevexchange, exchangetransferdate, newlistingdate, industrysymbol FROM Stock WHERE symbol = ?
`

func (q *Queries) GetStockDataBySymbol(ctx context.Context, symbol sql.NullString) (Stock, error) {
	row := q.db.QueryRowContext(ctx, getStockDataBySymbol, symbol)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Address1,
		&i.City,
		&i.State,
		&i.Zip,
		&i.Country,
		&i.Phone,
		&i.Fax,
		&i.Website,
		&i.Industry,
		&i.Industrykey,
		&i.Industrydisp,
		&i.Sector,
		&i.Sectorkey,
		&i.Sectordisp,
		&i.Longbusinesssummary,
		&i.Fulltimeemployees,
		&i.Auditrisk,
		&i.Boardrisk,
		&i.Compensationrisk,
		&i.Shareholderrightsrisk,
		&i.Overallrisk,
		&i.Governanceepochdate,
		&i.Compensationasofepochdate,
		&i.Irwebsite,
		&i.Maxage,
		&i.Pricehint,
		&i.Previousclose,
		&i.Open,
		&i.Daylow,
		&i.Dayhigh,
		&i.Regularmarketpreviousclose,
		&i.Regularmarketopen,
		&i.Regularmarketdaylow,
		&i.Regularmarketdayhigh,
		&i.Dividendrate,
		&i.Dividendyield,
		&i.Exdividenddate,
		&i.Payoutratio,
		&i.Fiveyearavgdividendyield,
		&i.Beta,
		&i.Trailingpe,
		&i.Forwardpe,
		&i.Volume,
		&i.Regularmarketvolume,
		&i.Averagevolume,
		&i.Averagevolume10days,
		&i.Averagedailyvolume10day,
		&i.Bid,
		&i.Ask,
		&i.Bidsize,
		&i.Asksize,
		&i.Marketcap,
		&i.Fiftytwoweeklow,
		&i.Fiftytwoweekhigh,
		&i.Pricetosalestrailing12months,
		&i.Fiftydayaverage,
		&i.Twohundreddayaverage,
		&i.Trailingannualdividendrate,
		&i.Trailingannualdividendyield,
		&i.Currency,
		&i.Tradeable,
		&i.Enterprisevalue,
		&i.Profitmargins,
		&i.Floatshares,
		&i.Sharesoutstanding,
		&i.Sharesshort,
		&i.Sharesshortpriormonth,
		&i.Sharesshortpreviousmonthdate,
		&i.Dateshortinterest,
		&i.Sharespercentsharesout,
		&i.Heldpercentinsiders,
		&i.Heldpercentinstitutions,
		&i.Shortratio,
		&i.Shortpercentoffloat,
		&i.Impliedsharesoutstanding,
		&i.Bookvalue,
		&i.Pricetobook,
		&i.Lastfiscalyearend,
		&i.Nextfiscalyearend,
		&i.Mostrecentquarter,
		&i.Earningsquarterlygrowth,
		&i.Netincometocommon,
		&i.Trailingeps,
		&i.Forwardeps,
		&i.Lastsplitfactor,
		&i.Lastsplitdate,
		&i.Enterprisetorevenue,
		&i.Enterprisetoebitda,
		&i.Fiftytwoweekchange,
		&i.Sandp52weekchange,
		&i.Lastdividendvalue,
		&i.Lastdividenddate,
		&i.Quotetype,
		&i.Currentprice,
		&i.Targethighprice,
		&i.Targetlowprice,
		&i.Targetmeanprice,
		&i.Targetmedianprice,
		&i.Recommendationmean,
		&i.Recommendationkey,
		&i.Numberofanalystopinions,
		&i.Totalcash,
		&i.Totalcashpershare,
		&i.Ebitda,
		&i.Totaldebt,
		&i.Quickratio,
		&i.Currentratio,
		&i.Totalrevenue,
		&i.Debttoequity,
		&i.Revenuepershare,
		&i.Returnonassets,
		&i.Returnonequity,
		&i.Grossprofits,
		&i.Freecashflow,
		&i.Operatingcashflow,
		&i.Earningsgrowth,
		&i.Revenuegrowth,
		&i.Grossmargins,
		&i.Ebitdamargins,
		&i.Operatingmargins,
		&i.Financialcurrency,
		&i.Symbol,
		&i.Language,
		&i.Region,
		&i.Typedisp,
		&i.Quotesourcename,
		&i.Triggerable,
		&i.Custompricealertconfidence,
		&i.Postmarkettime,
		&i.Regularmarkettime,
		&i.Exchange,
		&i.Messageboardid,
		&i.Exchangetimezonename,
		&i.Shortname,
		&i.Longname,
		&i.Postmarketchangepercent,
		&i.Postmarketprice,
		&i.Postmarketchange,
		&i.Regularmarketchange,
		&i.Regularmarketdayrange,
		&i.Fullexchangename,
		&i.Averagedailyvolume3month,
		&i.Fiftytwoweeklowchange,
		&i.Fiftytwoweeklowchangepercent,
		&i.Fiftytwoweekrange,
		&i.Fiftytwoweekhighchange,
		&i.Fiftytwoweekhighchangepercent,
		&i.Fiftytwoweekchangepercent,
		&i.Dividenddate,
		&i.Earningstimestamp,
		&i.Earningstimestampstart,
		&i.Earningstimestampend,
		&i.Earningscalltimestampstart,
		&i.Earningscalltimestampend,
		&i.Isearningsdateestimate,
		&i.Epstrailingtwelvemonths,
		&i.Epsforward,
		&i.Epscurrentyear,
		&i.Priceepscurrentyear,
		&i.Fiftydayaveragechange,
		&i.Fiftydayaveragechangepercent,
		&i.Twohundreddayaveragechange,
		&i.Twohundreddayaveragechangepercent,
		&i.Sourceinterval,
		&i.Exchangedatadelayedby,
		&i.Hasprepostmarketdata,
		&i.Firsttradedatemilliseconds,
		&i.Exchangetimezoneshortname,
		&i.Gmtoffsetmilliseconds,
		&i.Market,
		&i.Esgpopulated,
		&i.Regularmarketchangepercent,
		&i.Regularmarketprice,
		&i.Marketstate,
		&i.Averageanalystrating,
		&i.Cryptotradeable,
		&i.Displayname,
		&i.Trailingpegratio,
		&i.Address2,
		&i.Prevname,
		&i.Namechangedate,
		&i.Ipoexpecteddate,
		&i.Prevticker,
		&i.Tickerchangedate,
		&i.Prevexchange,
		&i.Exchangetransferdate,
		&i.Newlistingdate,
		&i.Industrysymbol,
	)
	return i, err
}

const highCashFlowBySector = `-- name: HighCashFlowBySector :many
SELECT s1.symbol, s1.displayName, s1.sector, s1.freeCashflow AS maxFCF
FROM Stock s1
WHERE s1.sector != 'None' 
  AND s1.sector != '' 
  AND LOWER(s1.sector) = ?
  AND (
      SELECT COUNT(*) 
      FROM Stock s2 
      WHERE s2.sector = s1.sector 
        AND s2.freeCashflow > s1.freeCashflow
  ) < ?
ORDER BY s1.freeCashflow DESC LIMIT 5
`

type HighCashFlowBySectorParams struct {
	Sector   sql.NullString
	Sector_2 sql.NullString
}

type HighCashFlowBySectorRow struct {
	Symbol      sql.NullString
	Displayname sql.NullString
	Sector      sql.NullString
	Maxfcf      sql.NullInt64
}

func (q *Queries) HighCashFlowBySector(ctx context.Context, arg HighCashFlowBySectorParams) ([]HighCashFlowBySectorRow, error) {
	rows, err := q.db.QueryContext(ctx, highCashFlowBySector, arg.Sector, arg.Sector_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HighCashFlowBySectorRow
	for rows.Next() {
		var i HighCashFlowBySectorRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Displayname,
			&i.Sector,
			&i.Maxfcf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
